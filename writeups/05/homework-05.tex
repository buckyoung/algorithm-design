 
%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Greedy Algorithms \& Dynamic Programming}
\newcommand{\hmwkProblems}{12, 13 and 1}
\newcommand{\hmwkDueDate}{Monday September 8, 2014}
\newcommand{\ClassName}{Algorithm Design}
\newcommand{\ClassNumber}{CS 1510}
\newcommand{\hmwkAuthorName}{Buck Young and Rob Brown}



%
% Basic Document Settings
%

\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amssymb}

\usetikzlibrary{automata,positioning}


\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in\newcommand{\hmwkClassTime}{Section A}
\linespread{1.1}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\setlength\parindent{0pt}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

\newenvironment{homeworkProblem}{
    \section{ }
    %\setcounter{partCounter}{1}
    %\enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}



% 
% Header and Footer definition
%

\pagestyle{fancy}
\lhead{\ClassNumber\ - \ClassName}
\chead{\hmwkTitle}
\rhead{Problems \hmwkProblems}
\lfoot{\lastxmark}
\cfoot{\thepage}


%
% Title Page
%

\title{
    \vspace{2in}
	\textmd{\textbf{\ClassNumber}} \\
    \textmd{\textbf{\ClassName}} \\    
    \normalsize\vspace{0.1in}\small{\hmwkTitle} \\
    \normalsize\vspace{0.1in}\small{Problems \hmwkProblems} \\
	\normalsize\vspace{0.1in}\small{Due \hmwkDueDate}    \\
    \vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}






% 	% 	%	%	%	%	%
%	Document Start 		%
% 	% 	% 	% 	% 	% 	%

\begin{document}

\maketitle

\pagebreak




\begin{homeworkProblem}
\centerline{\textbf{Problem 12}}
\leavevmode
\textbf{Input:}
\\
\textbf{Output:} 
\\
\textbf{Theorem:} 
\\ \\
\textbf{Proof:} 
\end{homeworkProblem}



\pagebreak



\begin{homeworkProblem}
\centerline{\textbf{Problem 13}}
\leavevmode
\textbf{(a)} 
\\
\textbf{Input:} A set of $n$ jobs $j$ -- each job is described by an integer release time and deadline ($r_j$, $d_j$) -- each of which must run for one unit of time. Additionally at each time interval t $\in$ [0, $T$), the machine may be ON or OFF at the time interval ($t$, $t+1$). Let $T$ equal the maximum deadline -- max($d_j$) for all $j$
\\ \\
\textbf{Output:} Whether or not a feasible sequence was found in which every job ran for one unit of time at some interval after $r_j$ and before $d_j$.
\\ \\
\textbf{Algorithm:} Run the job with the earliest deadline first:
\begin{algorithmic}
\While{$t$ $\textless$ $T$}
	\If{the machine is on at time $t$}
		\For{each job that has not yet run \&\& is released -- ($r_j$ $\leq$ $t$)}
			\State Run the job with the earliest deadline -- (min($d_j$) for all $j$) -- (break ties arbitrarily)
		\EndFor
	\EndIf
\EndWhile
\\
\If{all jobs in the input $I$ have run by time $T$}
	\State return FEASIBLE
\Else
	\State return NOT FEASIBLE
\EndIf
\end{algorithmic}
\leavevmode
\\
\textbf{Theorem:} The described "earliest deadline first" algorithm EDF is correct.
\\ \\
\textbf{Proof:} Assume to reach a contradiction that there exists an input on which EDF produces an unacceptable output.
\\ \\
Let EDF(I) = \{$j_{\alpha(1)}$, ..., $j_{\alpha(n)}$\} be the output of EDF on input I
\\ \& OPT(I) = \{$j_{\beta(1)}$, ..., $j_{\beta(n)}$\} be the optimal solution which agrees with EDF(I) for the most number of steps
\\ \\ Let $k$ be the first point of disagreement between EDF and OPT
\\ \\ \\ \\ \\ \\ \\
Let OPT' equal opt with $j_{\alpha(k)}$ and $j_{\beta(k)}$ switched.
\\ \\ \\ \\ \\ \\ \\ \\ \\ \\
Clearly OPT' is more like EDF. In order to prove that it still produces an acceptable output, consider the following four cases. Also note that by the definition of EDF, we know that the deadline $d_{\alpha(k)}$ is earlier than (or tied with) the deadline $d_{\beta(k)}$ -- $d_{\alpha(k)}$ $\leq$ $d_{\beta(k)}$
\\ \\
\centerline{\textbf{Case 1: Both EDF and OPT determined the solution was FEASIBLE}}
\\ \\
Since we know $d_{\alpha(k)}$ $\leq$ $d_{\beta(k)}$, we know that $d_{\beta(k)}$ is after the scheduled $j_{\alpha(k)}$ in OPT. Therefore we can easily switch $j_{\alpha(k)}$ and $j_{\beta(k)}$ and both jobs will complete before their deadlines. Therefore an acceptable solution is still produced.
\\ \\ \\
\centerline{\textbf{Case 2: Both EDF and OPT determined the solution was NOT FEASIBLE}}
\\ \\
Since a NOT FEASIBLE solution was determined, we know that some job was unable to be scheduled before its deadline. Therefore switching $j_{\beta(k)}$ and $j_{\alpha(k)}$ (or scheduling one and not the other) should have no affect on the final outcome and an acceptable solution is still produced. 
\\ \\ \\
\centerline{\textbf{Case 3: EDF determined FEASIBLE but OPT determined NOT FEASIBLE}}
\\ \\
This state is impossible by the definition of OPT. If EDF was able to create a FEASIBLE solution, then OPT is guaranteed to also produce a FEASIBLE solution, by definition.
\\ \\ \\
\centerline{\textbf{Case 4: EDF determined NOT FEASIBLE but OPT determined FEASIBLE}}
\\ \\
In this case, we can do the switch using what we know about the deadlines ($d_{\alpha(k)}$ $\leq$ $d_{\beta(k)}$) and OPT' still produces an acceptable solution.
\\ \\ \\ \\
All in all, OPT' always produces an acceptable solution.
\\ \\
$\therefore$ We have reached a contradiction because OPT' is more like EDF for one more step even though OPT was defined as being most like EDF. 
\end{homeworkProblem}



\pagebreak



\begin{homeworkProblem}
\centerline{\textbf{Problem 13}}
\leavevmode
\textbf{(b)} 
\\
\textbf{Input:}
\\
\textbf{Output:} 
\\ \\
\textbf{Algorithm:} 
\\ \\
\textbf{Theorem:} 
\\
\textbf{Proof:} 
\end{homeworkProblem}



\pagebreak



\begin{homeworkProblem}
\centerline{\textbf{Problem 1}}
\leavevmode
\textbf{(a)} 
\\
\begin{algorithmic}
\Procedure{T}{int $n$}
	\If{n == 0 or n==1}
  		\State return 2;
	\EndIf
	
	\State SUM = 0
	\For {$1 \le i \le n-1$}
		\State SUM+=T(i)*T(i-1)
	\EndFor	
	\State \Return SUM
\EndProcedure
\end{algorithmic}
\leavevmode
\\
\textbf{(b)} 
\\
\begin{algorithmic}
\Procedure{T}{int $n$}
	\If{n == 0 or n==1}
  		\State return 2;
	\EndIf
	
	\State T[0] = 2, T[1] = 2
	\For {$2 \le i \le n$}
		\State SUM = 0
		\For {$1 \le j \le n-1$}
			\State SUM+=T[j]*T[j-1]
		\EndFor
	T[i] = SUM
	\EndFor	
	\State \Return T[n]
\EndProcedure
\end{algorithmic}
\leavevmode
\\
\textbf{(c)} 
\\
\begin{algorithmic}
\Procedure{T}{int $n$}
	\If{n == 0 or n==1}
  		\State return 2;
	\EndIf
	
	\State T[0] = 2, T[1] = 2, T[2] = 4
	\For {$3 \le i \le n$}
		\State T[i] = T[i-1]*T[i-2] + T[i-1]
	\EndFor	
	\State \Return T[n]
\EndProcedure
\end{algorithmic}
\leavevmode
\\

\end{homeworkProblem}



\end{document}