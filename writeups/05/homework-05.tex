 
%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Greedy Algorithms \& Dynamic Programming}
\newcommand{\hmwkProblems}{12, 13 and 1}
\newcommand{\hmwkDueDate}{Monday September 8, 2014}
\newcommand{\ClassName}{Algorithm Design}
\newcommand{\ClassNumber}{CS 1510}
\newcommand{\hmwkAuthorName}{Buck Young and Rob Brown}



%
% Basic Document Settings
%

\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amssymb}

\usetikzlibrary{automata,positioning}


\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in\newcommand{\hmwkClassTime}{Section A}
\linespread{1.1}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\setlength\parindent{0pt}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

\newenvironment{homeworkProblem}{
    \section{ }
    %\setcounter{partCounter}{1}
    %\enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}



% 
% Header and Footer definition
%

\pagestyle{fancy}
\lhead{\ClassNumber\ - \ClassName}
\chead{\hmwkTitle}
\rhead{Problems \hmwkProblems}
\lfoot{\lastxmark}
\cfoot{\thepage}


%
% Title Page
%

\title{
    \vspace{2in}
	\textmd{\textbf{\ClassNumber}} \\
    \textmd{\textbf{\ClassName}} \\    
    \normalsize\vspace{0.1in}\small{\hmwkTitle} \\
    \normalsize\vspace{0.1in}\small{Problems \hmwkProblems} \\
	\normalsize\vspace{0.1in}\small{Due \hmwkDueDate}    \\
    \vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}






% 	% 	%	%	%	%	%
%	Document Start 		%
% 	% 	% 	% 	% 	% 	%

\begin{document}

\maketitle

\pagebreak




\begin{homeworkProblem}
\centerline{\textbf{Problem 12}}
\leavevmode
\textbf{Input:} Positive integers $r_1, r_2, ..., r_n$ and $c_1, c_2, ..., c_n$
\\
\textbf{Output:} An $n$ by $n$ matrix with 0/1 entries such that for all $i$ the sum of the $i^{th}$ row in a is $r_i$ and the sum of the $i^{th}$ column is $c_i$.
\\
\textbf{Theorem:} The greedy algorithm (G) given in problem 12 is correct.
\\ \\
\textbf{Proof:} Suppose for the purpose of reaching a contradiction that there exists some input $R = \{r_1, r_2, ..., r_n\}$ and $C = \{c_1, c_2, ..., c_n\}$ such that G produces unacceptable output. Let $G(R, C) = A$ be the matrix that G produces, and let $OPT(R, C) = B$ be the matrix that some optimal algorithm which agrees for the most number of steps produces.
\\ \\
Consider the first pair of indices $(i, j)$ where the indexed values of A disagree with those of B. In other words, consider $(i, j)$ such that $\forall(x, y) \le (i, j): a_{ij} = b_{ij}$.
\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 
Since $a_{ij} = b_{ij}$, and both A and B consist entirely of 0/1 values, we have two cases:
\\ \\
\centerline{ 1) $a_{i,j} = 0$ and $b_{i,j} = 1$}
\\
\centerline{ 2) $a_{i,j} = 1$ and $b_{i,j} = 0$}
\\ \\
Consider case 1. Since $b_{i,j} = 1$ and $(\sum_{w=1}^{n} b_{i,w})= r_i$ we know that in some column ($m$) of B's $i^{th}$ row there exists $b_{i,m} = 0$ where $b_{i,m} \ne a_{i,m}$ (ie, $a_{i,m} = 1$). A is constructed so that the $a_i^{th}$ row has exactly $r_i$ 1's. If OPT gives B a 1 at $(i,j)$, it must compensate later by NOT having a 0 at some later point. This is the value we call $b_{i,m}$. Likewise, since OPT must produce $(\sum_{h=1}^{n} b_{h,i}) = c_j$, there must be some $b_{k,j}$ in the $j^{th}$ column of B such that $b_{k,j} = 0$ and $a_{k,j} = 1$. 
\\ \\ 
By the same logic, for case 2 we can deduce that there is some column ($m$) in B's $i^{th}$ row where $b_{i,m} = 1$ and $a_{i,m} = 0$; likewise, there is some row $k$ in B's $j^{th}$ column where $b_{k, j} =1$ and $a_{k,j} = 0$. 
\\ \\
Let the output of OPT' on I equal B with the values of $b_{i,j}$, $b_{i, m}$, and $b_{k,j}$ changed to their opposite values. If OPT was indeed correct to begin with, then we see the following result for the two possible cases.
\\ \\
\centerline{CASE 1}
\centerline{$\sum_{w=1}^{n} b_{i,w} = r_i =  r_i - b_{i,m} - b_{i,j} + !(b_{i, m}) + !(b_{i, j}) =  (r_i  -1 + 1 = r_i$}




\end{homeworkProblem}



\pagebreak
\pagebreak



\begin{homeworkProblem}
\centerline{\textbf{Problem 13}}
\leavevmode
\textbf{(a)} 
\\
\textbf{Input:} A set of $n$ jobs $j$ -- each job is described by an integer release time and deadline ($r_j$, $d_j$) -- each of which must run for one unit of time. Additionally at each time interval t $\in$ [0, $T$), the machine may be ON or OFF at the time interval ($t$, $t+1$). Let $T$ equal the maximum deadline -- max($d_j$) for all $j$.
\\ \\
\textbf{Output:} Whether or not a feasible sequence was found in which every job ran for one unit of time at some interval after $r_j$ and before $d_j$.
\\ \\
\textbf{Algorithm:} Run the job with the earliest deadline first:
\begin{algorithmic}
\While{$t$ $\textless$ $T$}
	\If{the machine is on at time $t$}
		\For{each job that has not yet run \&\& is released -- ($r_j$ $\leq$ $t$)}
			\State Run the job with the earliest deadline -- (min($d_j$) for all $j$) -- (break ties arbitrarily)
		\EndFor
	\EndIf
\EndWhile
\\
\If{all jobs in the input $I$ have run by time $T$}
	\State return FEASIBLE
\Else
	\State return NOT FEASIBLE
\EndIf
\end{algorithmic}
\leavevmode
\\
\textbf{Theorem:} The described "earliest deadline first" algorithm EDF is correct.
\\ \\
\textbf{Proof:} Assume to reach a contradiction that there exists an input on which EDF produces an unacceptable output.
\\ \\
Let EDF(I) = \{$j_{\alpha(1)}$, ..., $j_{\alpha(n)}$\} be the output of EDF on input I
\\ \& OPT(I) = \{$j_{\beta(1)}$, ..., $j_{\beta(n)}$\} be the optimal solution which agrees with EDF(I) for the most number of steps
\\ \\ Let $k$ be the first point of disagreement between EDF and OPT
\\ \\ \\ \\ \\ \\ \\
Let OPT' equal opt with $j_{\alpha(k)}$ and $j_{\beta(k)}$ switched.
\\ \\ \\ \\ \\ \\ \\ \\ \\ \\
Clearly OPT' is more like EDF. In order to prove that it still produces an acceptable output, consider the following four cases. Also note that by the definition of EDF, we know that the deadline $d_{\alpha(k)}$ is earlier than (or tied with) the deadline $d_{\beta(k)}$ -- $d_{\alpha(k)}$ $\leq$ $d_{\beta(k)}$
\\ \\
\centerline{\textbf{Case 1: Both EDF and OPT determined the solution was FEASIBLE}}
\\ \\
Since we know $d_{\alpha(k)}$ $\leq$ $d_{\beta(k)}$, we know that $d_{\beta(k)}$ is after the scheduled $j_{\alpha(k)}$ in OPT. Therefore we can easily switch $j_{\alpha(k)}$ and $j_{\beta(k)}$ and both jobs will complete before their deadlines. Therefore an acceptable solution is still produced.
\\ \\ \\
\centerline{\textbf{Case 2: Both EDF and OPT determined the solution was NOT FEASIBLE}}
\\ \\
Since a NOT FEASIBLE solution was determined, we know that some job was unable to be scheduled before its deadline. Therefore switching $j_{\beta(k)}$ and $j_{\alpha(k)}$ (or scheduling one and not the other) should have no affect on the final outcome and an acceptable solution is still produced. 
\\ \\ \\
\centerline{\textbf{Case 3: EDF determined FEASIBLE but OPT determined NOT FEASIBLE}}
\\ \\
This state is impossible by the definition of OPT. If EDF was able to create a FEASIBLE solution, then OPT is guaranteed to also produce a FEASIBLE solution, by definition.
\\ \\ \\
\centerline{\textbf{Case 4: EDF determined NOT FEASIBLE but OPT determined FEASIBLE}}
\\ \\
In this case, we can do the switch using what we know about the deadlines ($d_{\alpha(k)}$ $\leq$ $d_{\beta(k)}$) and OPT' still produces an acceptable solution.
\\ \\ \\ \\
All in all, OPT' always produces an acceptable solution.
\\ \\
$\therefore$ We have reached a contradiction because OPT' is more like EDF for one more step even though OPT was defined as being most like EDF. 
\end{homeworkProblem}



\pagebreak



\begin{homeworkProblem}
\centerline{\textbf{Problem 13}}
\leavevmode
\textbf{(b)} 
\\
\textbf{Input:} A set of $n$ jobs $j$ -- each job is described by an integer release time and deadline ($r_j$, $d_j$) -- each of which must run for one unit of time. Let $T$ equal the maximum deadline -- max($d_j$) for all $j$. Additionally, a positive integer $L$ is given which defines the length of an ON state.
\\ \\
\textbf{Output:} The minimum number $k$ times that the machine must turn ON in order to feasibly schedule all jobs within the intervals of length $L$.
\\ \\
\textbf{Algorithm:} While there are schedulable jobs in the input set, place an interval of length $L$ at the leftmost point $t$ where that interval ($t + L$) contains the most schedulable jobs $\leq$ $L$. Then schedule jobs within that interval according to the earliest deadline first.
\\(Note that a schedulable job is one that has been released and is not past it's deadline.)
\\ \\
\textbf{Theorem:} The described "left most" algorithm LM is correct.
\\ \\
\textbf{Proof:} Assume to reach a contradiction that there exists an input I on which LM produces and unacceptable output. 
\\ \\
Let $INT_1$, ..., $INT_n$ be the created intervals of length $L$ starting at $t_1$, ..., $t_n$
\\ \& LM(I) = \{$INT_{\alpha(1)}$, ..., $INT_{\alpha(n)}$\} be the output of LM on input I
\\ \& OPT(I)= \{$INT_{\beta(1)}$, ..., $INT_{\beta(n)}$\}  be the optimal solution which agrees with LM the most number of steps
\\ \& $k$ be the first point of disagreement between LM and OPT
\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\
Note: we know that $t_{\alpha(k)}$ $\textless$ $t_{\beta(k)}$, by the definition of LM
\\ \\
Let OPT' equal OPT with $INT_{\beta{k}}$ shifted to the left such that it starts at $t_{\alpha(k)}$ and is, of course, of length $L$ -- and therefore becomes (indistinguishable from) $INT_{\alpha(k)}$.
\\ \\
Clearly OPT' is more like LM for one additional interval.
\\ \\
A few observations about the shift:
\\ 1) OPT clearly hasn't missed scheduling a job, by the definition of OPT (therefore the space from $t_{\alpha(k)}$ to $t_{\beta(k)}$ is void of a completely unscheduled job in OPT) 
\\ \\ 2) OPT has not created an interval that scheduled more jobs than $INT_{\alpha(k)}$, by the definition of LM
\\ \\
Thus, shifting $INT_{\beta(k)}$ to the left so that it becomes $INT_{\alpha(k)}$ in OPT' will still produce an acceptable output.
\\ \\
$\therefore$ We have reached a contradiction because OPT' agrees with LM for one additional step despite OPT being defined as agreeing with LM for the most number of steps.

\end{homeworkProblem}



\pagebreak



\begin{homeworkProblem}
\centerline{\textbf{Problem 1}}
\leavevmode
\textbf{(a)}
\begin{algorithmic}
\Procedure{T}{int $n$}
	\If{$n < 0$}
		\State \Return -1
	\EndIf
	\If{n == 0 or n==1}
  		\State return 2;
	\EndIf
	
	\State SUM = 0
	\For {$1 \le i \le n-1$}
		\State SUM+=T(i)*T(i-1)
	\EndFor	
	\State \Return SUM
\EndProcedure
\end{algorithmic}
Recursive algorithms which only reduce the input by a constant size each call are inherently exponential. Here, we have an algorithm which does this (ie, only decreases the input size by a constant size each call), and additionally creates this many more recursive calls at each point in the recursion. Clearly, it is exponential. \\
\\
\textbf{(b)}
\begin{algorithmic}
\Procedure{T}{int $n$}
	\If{$n < 0$}
		\State \Return -1
	\EndIf
	\If{n == 0 or n==1}
  		\State return 2;
	\EndIf
	
	\State T[0] = 2, T[1] = 2
	\For {$2 \le i \le n$}
		\State SUM = 0
		\For {$1 \le j \le n-1$}
			\State SUM+=T[j]*T[j-1]
		\EndFor
	T[i] = SUM
	\EndFor	
	\State \Return T[n]
\EndProcedure
\end{algorithmic}
Clearly this algorithm is $\mathcal{O}(n^2)$. This is achieved by starting at the base $(n=0, n=1)$ and computing the the next value based on the sum of all the previous; as opposed to starting at the top and recomputing everything at each step closer to the base. \\
\\
\textbf{(c)} 
\begin{algorithmic}
\Procedure{T}{int $n$}
	\If{$n < 0$}
		\State \Return -1
	\EndIf
	\If{n == 0 or n==1}
  		\State \Return 2;
	\EndIf
	
	\State T[0] = 2, T[1] = 2, T[2] = 4
	\For {$3 \le i \le n$}
		\State T[i] = T[i-1]*T[i-2] + T[i-1]
	\EndFor	
	\State \Return T[n]
\EndProcedure
\end{algorithmic}
Clearly this algorithm is $\mathcal{O}(n)$.

\end{homeworkProblem}



\end{document}